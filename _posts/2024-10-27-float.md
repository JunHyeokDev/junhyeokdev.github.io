---
title: Float?
date: 2024-10-27 00:00:00 +0900
author: JunHyeokDev
categories: [Jungle Keyword, OS]
tags: [Study]
---

# 서론

컴퓨터는 `Floating` Point와 `Fixed` Point 두 가지 방식으로 실수를 표현할 수 있다. 그렇다면 두 표현 방식의 차이는 무엇일까??


## Fixed Point 

`Fixed Point` 표현방식은 말 그대로 소수를 표현하는 자릿수가 고정되어 있습니다.

소수점 이하 8자리, 정수부 7자리, 부호 1자리

예: +6.5859375의 표현
부호(0) | 정수부(0000110) | 소수부(10010110)
0 0000110 10010110

### 활용분야

1. 빠른 연산이 필요한 특정 게임엔진
2. 특정 OS (Pintos의 경우 `Fixed Point`로 소숫점을 표현하였다.)
3. 특정 임베디드 시스템

부동 소수점에 비해 구현이 간단하다. 그렇기 때문에 빠른 연산이 필요하거나, 리소스가 제한적인 경우에 `Fixed Point` 로 실수를 표현한다.


## Floating Point

`Floating Point` 는 부동 소수점 표현으로 보다 유동적으로 실수를 표현할 수 있습니다. 

5859375를 2진수로 변환해보겠습니다. 이 수는 정수부(6)와 소수부(0.5859375)로 나누어 각각 변환하면 됩니다.

### 2진수 변환 및 정규화 과정

#### 정수부(6) 변환
```
6 ÷ 2 = 3 나머지 0
3 ÷ 2 = 1 나머지 1
1 ÷ 2 = 0 나머지 1
∴ 6 = 110₂
```

#### 소수부(0.5859375) 변환
```
0.5859375 × 2 = 1.171875   → 1
0.171875 × 2 = 0.34375     → 0
0.34375 × 2 = 0.6875       → 0
0.6875 × 2 = 1.375         → 1
0.375 × 2 = 0.75           → 0
0.75 × 2 = 1.5             → 1
0.5 × 2 = 1.0              → 1
∴ 0.5859375 = 0.1001011₂
```

#### 결합
```
6.5859375 = 110.1001011₂
```

### 정규화 과정

#### 소수점 이동
```
110.1001011₂ = 1.101001011₂ × 2²
```
- 소수점을 왼쪽으로 이동하여 1.xxx 형태로 변환
- 이동한 자리수만큼 2의 지수로 표현

#### 최종 정규화 형태
```
1.101001011₂ × 2²

가수(M) = 101001011
지수(E) = 2
부호(S) = 0 (양수)
```

#### 검증
```
1.101001011₂ × 2² 
= (1 + 1×2⁻¹ + 0×2⁻² + 1×2⁻³ + ... + 1×2⁻⁹) × 2²
= (1 + 0.5 + 0 + 0.125 + ... + 0.001953125) × 4
= 1.6464844 × 4
= 6.5859375
```


#### 부호 비트
```
양수이므로 S = 0
```

#### 지수부 (8비트)
```
실제 지수: 2
편향값(Bias): 127
초과표현 지수: 2 + 127 = 129
2진수로 변환: 129₁₀ = 10000001₂
```

#### 가수부 (23비트)
```
정규화된 1.101001011 에서 소수점 이후만 저장
101001011 + 14개의 0을 채움
가수 = 10100101100000000000000
```

#### 최종 IEEE 754 표현
```
0 10000001 10100101100000000000000

S    E              M
```

#### 검증
```
1) 지수 복원: 10000001₂ - 127 = 129 - 127 = 2
2) 가수 복원: 1.10100101100000000000000
3) 값 계산: (-1)⁰ × 1.10100101100000000000000₂ × 2² = 6.5859375
```

이처럼 초과표현을 사용하면 음수 지수도 양수처럼 다룰 수 있어서, 예를 들어 -2의 지수는 125(127+(-2))로 표현됩니다. 이렇게 하면 단순 비트 비교만으로도 지수의 대소 비교가 가능합니다.


#### 1. Normalized Form 사용 이유

숫자의 유일한 표현을 보장하고 정밀도를 높이기 위함입니다
- 같은 수에 대한 중복 표현 방지 (예: 0.1×2² = 1.0×2¹ 방지)

#### 2. 지수 초과표현 사용 이유

부동소수점 수의 크기 비교를 단순한 정수 비교로 가능하게 하기 위함입니다
- 음수 지수도 양수로 표현되어 단순 비트 비교 가능
- 별도의 부호 비트 처리 로직이 불필요
- 하드웨어 구현이 단순화됨

#### 3. 지수부가 상위 비트에 위치하는 이유

부동소수점 수의 크기 비교 연산을 최적화하기 위함입니다
- 지수가 수의 크기를 결정하므로 상위 비트에서 빠른 비교 가능
- 지수 비교만으로 대소관계가 결정되는 경우 가수부 비교 불필요



Krafton Jungle 과정을 수료하며 `Floating Point` 및 `Fixed Point` 에 대해 공부하였는데 따로 정리를 하지 않아서 이번 기회에 다시 공부하였습니다.

아래 영상에서 핵심 내용을 자세히 배울 수 있었습니다!

https://www.youtube.com/watch?v=5R4qg45ZWA0
